from tortoise.models import Model
from tortoise.contrib.pydantic import pydantic_model_creator
from tortoise import fields
from .base import ReportStorageCRUD
from shared.models.task import TestResult
from typing import List, Any, Optional, Dict


class TestResultORM(Model):
    # TODO can we just extend TestTask?
    test_id = fields.IntField(pk=True)  # make it uuid
    brand = fields.CharField(max_length=255)
    location = fields.CharField(max_length=255)
    partition = fields.CharField(max_length=255)
    unit = fields.CharField(max_length=255)
    allure_link = fields.CharField(max_length=255)
    log_link = fields.CharField(max_length=255)
    ptr_address = fields.CharField(max_length=255)
    date_time = fields.DatetimeField()
    status = fields.CharField(max_length=255)
    reason = fields.CharField(max_length=255)
    duration = fields.IntField()

    class Meta:
        table = "test_results"
        indexes = (
            ("brand", "location"),
            ("brand", "partition", "unit"),
            (
                "partition",
                "unit",
                "brand",
                "location",
                "test_id",
            ),  # legacy grouping from PTL
        )


# TODO: Pydantic Base model have SYNC from_orm function.
# Async fetching from ORM implemented in Tortoise wrapper for pydantic BaseModel( PyWrapper.from_tortoise_orm() ) witch generated by next function.
# I will use this proxy Model to use async flow.
TestResultSchema = pydantic_model_creator(TestResultORM, name="TestResultSchema")


# TODO: THIS CRUD is hardcoed on TestResult. Can be coverted to generic CRUD with specific successors
class SQLStorageCRUD(ReportStorageCRUD):
    def __init__(self):
        # FIXME Should i fix hardcode? -> If do generic base CRUD
        self.model = TestResultORM
        self.schema = TestResultSchema

    @classmethod
    def _convert_models(
        cls, orm_schemas: Any[List[TestResultSchema], TestResultSchema]
    ) -> Any[List[TestResult], TestResult]:
        """This is a sync method which work with already asyncly fetched data"""
        if isinstance(list, orm_schemas):
            return [TestResult.parse_obj(obj) for obj in orm_schemas]
        return TestResult.parse_obj(orm_schemas)

    async def get_field_values(self, fields: List[str]) -> Dict[str, List]:
        """Get all values from Test reports property"""
        # TODO Check if we need this? With ORM it is a dirty hack
        # TODO Validation of fields?
        #       tortoise can raise FieldError exception. Should it be catched?
        unsorted = await self.model.all().values(*fields)
        result = {}
        for field in fields:
            result[field] = set(item[field] for item in unsorted)
        return result

    async def get_by_filters(
        self,
        order_by: Optional[List[str]] = None,
        filters: Optional[Dict[str, str]] = {},
        page_limit: int = 0,
        page_offset: int = 0,
    ) -> List[TestResult]:
        """Get reports by props filter"""
        # TODO add more strict type hinting
        # TODO order_by does not implemented, do we need this?
        if order_by:
            orm_data = (
                self.model.filter(**filters)
                .order_by(order_by)
                .offset(page_offset)
                .limit(page_limit)
            )
        else:
            orm_data = (
                self.model.filter(**filters).offset(page_offset).limit(page_limit)
            )
        return self._convert_models(await self.schema.from_queryset(orm_data))

    async def get_by_id(self, test_id: int) -> TestResult:
        """get single test result by provided id"""
        return self._convert_models(
            await self.schema.from_queryset_single(self.model.get(test_id=test_id))
        )

    async def add(self, report: TestResult) -> TestResult:
        """Add new test report to storage"""
        obj = await self.model.create(**report.dict(exclude_unset=True))
        return self._convert_models(await self.schema.from_tortoise_orm(obj))
